--- netkit-rsh-0.17/rlogind/rlogind.c	2013-04-01 14:07:28.631790857 -0400
+++ netkit-rsh-0.17/rlogind/rlogind.c	2013-04-01 14:09:17.300050652 -0400
@@ -72,7 +72,8 @@ 
 #include "logwtmp.h"
 #include "rlogind.h"
 
-pid_t forkpty(int *, char *, struct termios *, struct winsize *);
+#include <pty.h>
+#include <utmp.h>
 int logout(const char *);
 
 #ifndef TIOCPKT_WINDOW
@@ -421,12 +422,33 @@ 
 	write(netfd, "rlogind: Host address mismatch.\r\n", 33);
     }
 
-    pid = forkpty(&master, line, NULL, &win);
-    if (pid < 0) {
+/*  We can no longer call forkpty here (a convenience routine that combines
+    openpty, fork, and login_tty) because, with forkpty, the slave end of
+    the pty is open only in the child process. The child process execs
+    /bin/login which now closes all open file descriptors before doing a
+    vhangup (see lkml.org/lkml/2012/6/5/145), and this resets packet mode
+    on the pty, undoing the effect of the ioctl(master, TIOCPKT, &on) call
+    made by the parent.
+
+    Instead, we call openpty, fork, and login_tty individually, so that we
+    can keep a file descriptor to the slave open in the parent process,
+    thereby retaining packet mode even when the child closes file descriptors
+    to call vhangup. */
+
+    int slave;
+    int err = openpty(&master, &slave, line, NULL, &win);
+    if (err) {
 	if (errno == ENOENT) fatal(netfd, "Out of ptys", 0);
-	fatal(netfd, "Forkpty", 1);
+	fatal(netfd, "Openpty", 1);
+    }
+    signal(SIGHUP, SIG_IGN);
+    pid = fork();
+    if (pid < 0) {
+	fatal(netfd, "Fork", 1);
     }
     if (pid == 0) {
+	close(master);
+  	login_tty(slave);
 	/* netfd should always be 0, but... */ 
 	if (netfd > 2) close(netfd);
 	child(hname, termtype, lusername, authenticated, rusername);
